<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Receiver - Type 2 (Object & Face Recognition)</title>
<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%);min-height:100vh;padding:20px}
.container{max-width:1400px;margin:0 auto;background:white;border-radius:15px;box-shadow:0 20px 60px rgba(0,0,0,0.3);padding:30px}
h1{color:#f5576c;text-align:center;margin-bottom:10px}
.status{text-align:center;padding:10px;border-radius:8px;margin-bottom:20px;font-weight:bold}
.status.connected{background:#d4edda;color:#155724}
.status.disconnected{background:#f8d7da;color:#721c24}
.peer-id{text-align:center;color:#666;margin-bottom:20px;font-size:14px}
.broadcasters-section{margin-bottom:30px}
.broadcasters-section h2{color:#f5576c;margin-bottom:15px}
.broadcaster-list{display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:15px;margin-bottom:20px}
.broadcaster-item{padding:15px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;border-radius:10px;cursor:pointer;transition:all 0.3s;text-align:center;font-weight:bold}
.broadcaster-item:hover{transform:translateY(-5px);box-shadow:0 10px 25px rgba(0,0,0,0.2)}
.broadcaster-item.connected{background:linear-gradient(135deg,#27ae60 0%,#229954 100%)}
.streams-container{display:grid;grid-template-columns:repeat(auto-fit,minmax(400px,1fr));gap:20px;margin-bottom:30px}
.stream-box{background:#f8f9fa;border-radius:10px;padding:15px;box-shadow:0 5px 15px rgba(0,0,0,0.1);position:relative}
.stream-box h3{color:#667eea;margin-bottom:10px;font-size:16px}
.video-container{position:relative;background:#000;border-radius:8px;overflow:hidden;margin-bottom:10px}
video{width:100%;display:block}
.overlay-canvas{position:absolute;left:0;top:0;pointer-events:none}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
.disconnect-btn{width:100%;padding:8px;background:#e74c3c;color:white;border:none;border-radius:5px;cursor:pointer;font-weight:bold;transition:all 0.3s}
.disconnect-btn:hover{background:#c0392b}
.messages-section{margin-top:30px;padding:20px;background:#f8f9fa;border-radius:10px}
.messages-section h2{color:#f5576c;margin-bottom:15px}
.messages-container{max-height:300px;overflow-y:auto;padding:10px;background:white;border-radius:8px}
.message-item{padding:12px;margin-bottom:10px;border-radius:8px;background:#e3f2fd;border-left:4px solid #2196F3}
.message-item.file{background:#fff3e0;border-left-color:#ff9800}
.message-header{display:flex;justify-content:space-between;margin-bottom:5px;font-size:12px;color:#666}
.file-download{display:inline-block;margin-top:8px;padding:8px 15px;background:#ff9800;color:white;text-decoration:none;border-radius:5px;font-size:14px;font-weight:bold}
.refresh-btn{padding:10px 20px;background:#667eea;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;margin-bottom:15px}
.small{font-size:12px;color:#444}
.form-inline{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.input{padding:8px;border-radius:6px;border:1px solid #ccc}
.toggle{padding:8px 12px;background:#667eea;color:white;border:none;border-radius:6px;cursor:pointer}
</style>
</head>
<body>
<div class="container">
<h1>📺 Receiver Client — Object & Face Recognition</h1>
<div id="status" class="status disconnected">Disconnected</div>
<div class="peer-id">Your Peer ID: <strong id="peerIdDisplay">Connecting...</strong></div>
<div class="broadcasters-section">
<h2>Available Broadcasters</h2>
<button class="refresh-btn" onclick="refreshBroadcasters()">Refresh List</button>
<div id="broadcasterList" class="broadcaster-list"><p style="color:#666">Loading broadcasters...</p></div>
</div>
<div style="display:flex;gap:12px;align-items:center;margin-bottom:18px">
<div class="form-inline">
<label class="small">Object Detection</label>
<button id="toggleObject" class="toggle" onclick="toggleObjectDetection()">Loading</button>
</div>
<div class="form-inline">
<label class="small">Face Recognition</label>
<button id="toggleFace" class="toggle" onclick="toggleFaceRecognition()">Loading</button>
</div>
<div class="form-inline" style="margin-left:auto">
<label class="small">Detection Interval (ms)</label>
<input id="intervalInput" class="input" type="number" value="250" style="width:88px" />
</div>
</div>
<div style="display:flex;gap:12px;align-items:center;margin-bottom:16px">
<div>
<label class="small">Register Known Person</label>
<input id="personName" class="input" type="text" placeholder="Person Name" />
<input id="personFiles" type="file" multiple accept="image/*" />
<button class="toggle" onclick="registerPerson()">Register</button>
</div>
<div style="margin-left:12px">
<label class="small">Known Persons</label>
<div id="knownList" class="small" style="padding:8px;background:#fff;border-radius:6px;max-height:64px;overflow:auto"></div>
</div>
</div>
<div id="streamsContainer" class="streams-container"></div>
<div class="messages-section">
<h2>Messages & Files</h2>
<div id="messagesContainer" class="messages-container"><p style="color:#999;text-align:center">No messages yet</p></div>
</div>
</div>

<script>
const SERVER_URL = 'localhost:9000'
let peer = null
let activeStreams = new Map()
let dataConnections = new Map()
let messages = []
let cocoModel = null
let faceModelsLoaded = false
let faceMatcher = null
let labeledDescriptors = []
let objectDetectionEnabled = true
let faceRecognitionEnabled = true
let detectionInterval = 0
let lastRun = new Map()

async function initModels(){
await cocoSsd.load().then(m=>cocoModel=m)
await faceapi.nets.tinyFaceDetector.loadFromUri('/models')
await faceapi.nets.faceRecognitionNet.loadFromUri('/models')
await faceapi.nets.faceLandmark68Net.loadFromUri('/models')
faceModelsLoaded=true
updateToggleButtons()
updateKnownList()
}

function updateToggleButtons(){
document.getElementById('toggleObject').textContent = objectDetectionEnabled ? 'Enabled' : 'Disabled'
document.getElementById('toggleFace').textContent = faceRecognitionEnabled ? 'Enabled' : 'Disabled'
}

function toggleObjectDetection(){
objectDetectionEnabled = !objectDetectionEnabled
updateToggleButtons()
}

function toggleFaceRecognition(){
faceRecognitionEnabled = !faceRecognitionEnabled
updateToggleButtons()
}

async function registerPerson(){
const name = document.getElementById('personName').value.trim()
const files = document.getElementById('personFiles').files
if(!name||files.length===0) return
const descriptors = []
for(const file of files){
const img = await loadImageFromFile(file)
const detections = await faceapi.detectSingleFace(img,new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor()
if(detections && detections.descriptor) descriptors.push(detections.descriptor)
}
if(descriptors.length>0) labeledDescriptors.push(new faceapi.LabeledFaceDescriptors(name,descriptors))
faceMatcher = labeledDescriptors.length? new faceapi.FaceMatcher(labeledDescriptors,0.6):null
document.getElementById('personName').value=''
document.getElementById('personFiles').value=''
updateKnownList()
}

function updateKnownList(){
const container = document.getElementById('knownList')
container.innerHTML = labeledDescriptors.length? labeledDescriptors.map(ld=>ld.label).join(', '):'No registered persons'
}

function loadImageFromFile(file){
return new Promise((res,rej)=>{
const reader = new FileReader()
reader.onload = ()=>{const img = new Image();img.src=reader.result;img.onload=()=>res(img);img.onerror=rej}
reader.onerror=rej
reader.readAsDataURL(file)
})
}

function initPeer(){
peer = new Peer({host:'localhost',port:9000,path:'/peerjs',debug:2})
peer.on('open',id=>{
document.getElementById('peerIdDisplay').textContent=id
registerReceiver(id)
updateStatus(true)
loadBroadcasters()
})
peer.on('error',err=>{updateStatus(false)})
peer.on('disconnected',()=>{updateStatus(false)})
peer.on('call',call=>{
const silentStreamPromise = createSilentStream()
silentStreamPromise.then(silent=>{
call.answer(silent)
call.on('stream',stream=>{
displayStream(call.peer,stream)
activeStreams.set(call.peer,{call,stream})
loadBroadcasters()
})
call.on('close',()=>removeStream(call.peer))
call.on('error',()=>removeStream(call.peer))
})
})
}

async function registerReceiver(peerId){
try{await fetch(`http://${SERVER_URL}/register/receiver`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({peerId})})}catch(e){}
}

async function loadBroadcasters(){
try{const res = await fetch(`http://${SERVER_URL}/broadcasters`);const data = await res.json();displayBroadcasters(data.broadcasters)}catch(e){}
}

function refreshBroadcasters(){loadBroadcasters()}

function displayBroadcasters(broadcasters){
const container = document.getElementById('broadcasterList')
if(!broadcasters||broadcasters.length===0){container.innerHTML='<p style="color:#999;">No broadcasters available</p>';return}
container.innerHTML=''
broadcasters.forEach(id=>{
const div = document.createElement('div')
div.className='broadcaster-item'
if(activeStreams.has(id)){div.classList.add('connected');div.textContent=`📡 ${id.substring(0,8)}... (Connected)`}
else{div.textContent=`📡 ${id.substring(0,8)}... (Click to connect)`;div.onclick=()=>connectToBroadcaster(id)}
container.appendChild(div)
})
}

async function connectToBroadcaster(broadcasterId){
if(activeStreams.has(broadcasterId)) return
const dataConn = peer.connect(broadcasterId)
dataConn.on('open',()=>{dataConnections.set(broadcasterId,dataConn)})
dataConn.on('data',data=>handleIncomingData(broadcasterId,data))
dataConn.on('close',()=>{dataConnections.delete(broadcasterId)})
try{
const silentStream = await createSilentStream()
const call = peer.call(broadcasterId,silentStream)
call.on('stream',remoteStream=>{
displayStream(broadcasterId,remoteStream)
activeStreams.set(broadcasterId,{call,stream:remoteStream})
loadBroadcasters()
})
call.on('close',()=>removeStream(broadcasterId))
call.on('error',err=>removeStream(broadcasterId))
}catch(err){alert('Failed to connect to broadcaster: '+err.message)}
}

async function createSilentStream(){
const canvas = document.createElement('canvas')
canvas.width=640;canvas.height=480
const ctx = canvas.getContext('2d')
ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height)
const canvasStream = canvas.captureStream()
const audioContext = new AudioContext()
const destination = audioContext.createMediaStreamDestination()
const oscillator = audioContext.createOscillator()
const gainNode = audioContext.createGain()
gainNode.gain.value=0.0001
oscillator.connect(gainNode);gainNode.connect(destination);oscillator.start()
const stream = new MediaStream([...canvasStream.getVideoTracks(),...destination.stream.getAudioTracks()])
return stream
}

function displayStream(broadcasterId,stream){
const container = document.getElementById('streamsContainer')
const streamBox = document.createElement('div')
streamBox.className='stream-box'
streamBox.id=`stream-${broadcasterId}`
streamBox.innerHTML=`
<h3>Broadcaster: ${broadcasterId.substring(0,12)}...</h3>
<div class="video-container">
<video autoplay playsinline></video>
<canvas class="overlay-canvas"></canvas>
</div>
<div class="controls">
<button class="disconnect-btn" onclick="disconnectFromBroadcaster('${broadcasterId}')">Disconnect</button>
</div>
`
container.appendChild(streamBox)
const video = streamBox.querySelector('video')
const overlay = streamBox.querySelector('canvas')
video.srcObject = stream
video.onloadedmetadata = ()=>{overlay.width=video.videoWidth;overlay.height=video.videoHeight;overlay.style.width=video.clientWidth+'px';overlay.style.height=video.clientHeight+'px';startDetectionLoop(broadcasterId,video,overlay)}
}

function removeStream(broadcasterId){
const streamBox = document.getElementById(`stream-${broadcasterId}`)
if(streamBox) streamBox.remove()
activeStreams.delete(broadcasterId)
dataConnections.delete(broadcasterId)
loadBroadcasters()
}

function disconnectFromBroadcaster(broadcasterId){
const streamData = activeStreams.get(broadcasterId)
if(streamData) streamData.call.close()
const dataConn = dataConnections.get(broadcasterId)
if(dataConn) dataConn.close()
removeStream(broadcasterId)
}

function handleIncomingData(broadcasterId,data){
if(data.type==='text'){addMessage({from:broadcasterId,type:'text',content:data.content,timestamp:data.timestamp})}
else if(data.type==='file'){addMessage({from:broadcasterId,type:'file',fileName:data.name,fileSize:data.size,mimeType:data.mimeType,fileData:data.data,timestamp:data.timestamp})}
}

function addMessage(message){messages.push(message);displayMessages()}

function displayMessages(){
const container = document.getElementById('messagesContainer')
if(messages.length===0){container.innerHTML='<p style="color:#999;text-align:center">No messages yet</p>';return}
container.innerHTML=''
messages.forEach(msg=>{
const div = document.createElement('div');div.className=`message-item ${msg.type}`
const timestamp = new Date(msg.timestamp).toLocaleString();const senderId = msg.from.substring(0,8)
if(msg.type==='text'){div.innerHTML=`<div class="message-header"><span><strong>From:</strong> ${senderId}...</span><span>${timestamp}</span></div><div class="message-content">${escapeHtml(msg.content)}</div>`}
else if(msg.type==='file'){const fileSizeKB = (msg.fileSize/1024).toFixed(2);div.innerHTML=`<div class="message-header"><span><strong>File from:</strong> ${senderId}...</span><span>${timestamp}</span></div><div class="message-content"><strong>📁 ${escapeHtml(msg.fileName)}</strong><br>Size: ${fileSizeKB} KB</div><a href="${msg.fileData}" download="${msg.fileName}" class="file-download">Download File</a>`}
container.appendChild(div)
})
container.scrollTop = container.scrollHeight
}

function escapeHtml(text){const div=document.createElement('div');div.textContent=text;return div.innerHTML}

function updateStatus(connected){const status=document.getElementById('status');if(connected){status.className='status connected';status.textContent='Connected to Server'}else{status.className='status disconnected';status.textContent='Disconnected'}}

window.addEventListener('beforeunload',async()=>{
if(peer){await fetch(`http://${SERVER_URL}/unregister`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({peerId:peer.id})})}
activeStreams.forEach((streamData)=>{streamData.call.close()})
dataConnections.forEach((conn)=>{conn.close()})
})

setInterval(()=>{loadBroadcasters()},5000)

function startDetectionLoop(broadcasterId,video,overlay){
lastRun.set(broadcasterId,0)
const ctx = overlay.getContext('2d')
async function loop(){
const now = Date.now()
const interval = parseInt(document.getElementById('intervalInput').value) || detectionInterval
if(now - lastRun.get(broadcasterId) >= interval){
overlay.width = video.videoWidth || overlay.width
overlay.height = video.videoHeight || overlay.height
ctx.clearRect(0,0,overlay.width,overlay.height)
if(objectDetectionEnabled && cocoModel){
try{
const detections = await cocoModel.detect(video)
detections.forEach(d=>{
if(d.score<0.35) return
ctx.strokeStyle='rgba(0,255,128,0.9)';ctx.lineWidth=2;ctx.strokeRect(d.bbox[0],d.bbox[1],d.bbox[2],d.bbox[3])
ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(d.bbox[0],d.bbox[1]-20,Math.max(80,ctx.measureText(d.class).width+10),20)
ctx.fillStyle='white';ctx.font='14px sans-serif';ctx.fillText(d.class+' '+(d.score*100).toFixed(0)+'%',d.bbox[0]+4,d.bbox[1]-6)
})
}catch(e){}
}
if(faceRecognitionEnabled && faceModelsLoaded){
try{
const detections = await faceapi.detectAllFaces(video,new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors()
detections.forEach(fd=>{
const box = fd.detection.box
ctx.strokeStyle='rgba(255,128,64,0.9)';ctx.lineWidth=2;ctx.strokeRect(box.x,box.y,box.width,box.height)
let label = 'Unknown'
if(faceMatcher && fd.descriptor){const best = faceMatcher.findBestMatch(fd.descriptor);label = best.label==='unknown'?'Unknown':best.label}
ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(box.x,box.y-20,Math.max(100,ctx.measureText(label).width+10),20)
ctx.fillStyle='white';ctx.font='14px sans-serif';ctx.fillText(label,box.x+4,box.y-6)
})
}catch(e){}
}
lastRun.set(broadcasterId,now)
}
requestAnimationFrame(loop)
}
requestAnimationFrame(loop)
}

initPeer()
initModels()
</script>
</body>
</html>
